
--- The reviewer ---:

run with:
docker-compose up

That should be all. Make sure none of your other processes uses port 13337
Otherwise change it in docker-compose.yml

pg info:

POSTGRES_USER:                      softdbd
POSTGRES_PASSWORD:                  softdbd
POSTGRES_DB:                        garbage

This is a Rest Api.

Currently open routes:




FILL ME DADDY OwO










--- Mindset(for me) ---

There will be multiple implementations of each entity.

The scripts in cat / dog will create the descriminators

Rust can't create inheritance for us. This is fine.


Postgres views must be implemented.
Access must be restricted.
This would be complicated for an ORM framework to handle. 
sqlx will be used for custom sql scripts. 

Ideas:
project will use docker-compose to initialize both rust and Postgres.

Postgres first (wait for it) -> Rust migrations gets started.

Two migration tactics: 
    1. function call in main function
    2. sqlx cli commands in docker file.

Complication: 
    sqlx macros somehow checks for database coherence. This would be cool,
    if it wasn't because it stops the program from compiling if the table doesn't exist.
    However, we're reliant on the sqlx function to be called in the main method.

    In other words: We can't execute the code, because we don't have the tables in the database,
    because we can't execute the code, because we don't have the tables in the database,
    because ... etc...
    So that's fucking annoying.

    Migration tactic 1 therefore requires an alternative to the query! macros. 
    Possibly execution of an .sql file?

Constraint:
    I am the only one using Rust. 

    The entire setup must be able to be created automatically by everyone with ONLY docker-compose.
    
    I can't expect that the client(or reviewer) will install all the dependencies related to the project.